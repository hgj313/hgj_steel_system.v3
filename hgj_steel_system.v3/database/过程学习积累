// 选择最优的模数钢材组合以满足当前需求
selectBestModule(demand, groupKey, force = false) { // 方法名，参数：demand（需求对象），groupKey（分组标识），force（布尔值，默认false）
  // this：指向当前类的实例（即SteelOptimizerV3对象），用于访问类的属性和方法
  // getOrCreateModuleSteelPool：类的方法，获取或新建一个钢材池对象
  // pool：变量，存储当前分组下的模数钢材池对象
  const pool = this.getOrCreateModuleSteelPool(groupKey);

  // findSingleSteelSolution：类的方法，查找是否有单根模数钢材能满足需求长度
  // demand.length：需求对象的length属性，表示所需的长度
  // singleSteel：变量，存储查找结果。如果有单根钢材能满足需求，则为该钢材对象，否则为null
  const singleSteel = this.findSingleSteelSolution(demand.length, pool);

  // if语句：判断singleSteel是否为真（即不是null/undefined/false等）
  // 如果找到了单根钢材，直接返回该钢材对象，方法执行到此结束
  if (singleSteel) return singleSteel;

  // this.constraints：当前对象的constraints属性，通常是一个约束配置对象
  // maxWeldingSegments：最大允许的焊接段数（整数）
  // if语句：判断是否允许焊接（即最大焊接段数大于1）
  if (this.constraints.maxWeldingSegments > 1) {
    // findMultiSteelSolution：类的方法，查找多根钢材组合能否满足需求
    // 参数分别为需求长度、钢材池、最大焊接段数
    // multiSteel：变量，存储多根组合的查找结果
    const multiSteel = this.findMultiSteelSolution(
      demand.length, // 需求长度（数字类型）
      pool, // 当前钢材池对象
      this.constraints.maxWeldingSegments // 最大焊接段数（整数）
    );
    // 如果找到了多根组合方案，返回该方案对象
    if (multiSteel) return multiSteel;
  }

  // 如果单根和多根组合都无法满足需求，说明是约束本身导致的无解
  // console.error：在控制台输出错误信息，便于调试和排查问题
  // 模板字符串（反引号包裹，${}内可插入变量）
  console.error(
    `❌ 真正的约束冲突：需求${demand.length}mm在W=${this.constraints.maxWeldingSegments}约束下无法满足`
  );
  // 返回null，表示无解
  return null;
}

// 尝试用多根模数钢材组合满足需求
findMultiSteelSolution(requiredLength, pool, maxSegments) { // 方法名，参数：requiredLength（需求长度），pool（钢材池对象），maxSegments（最大焊接段数）
  // pool.availableLengths：钢材池对象的availableLengths属性，是一个数组，存储所有可用的钢材长度（数字）
  // sort((a, b) => b - a)：对数组进行降序排序（从大到小），以便优先尝试较长的钢材
  // availableLengths：变量，存储排序后的长度数组
  const availableLengths = pool.availableLengths.sort((a, b) => b - a);

  // for循环：segments从2开始，递增到maxSegments（包含maxSegments）
  // 依次尝试用2段、3段、...、maxSegments段钢材组合来满足需求
  for (let segments = 2; segments <= maxSegments; segments++) {
    // findOptimalCombination：类的方法，用于查找在指定段数下，能否用availableLengths数组中的钢材组合出requiredLength
    // combination：变量，存储查找结果。如果找到了合适的组合，则为组合对象，否则为null
    const combination = this.findOptimalCombination(
      requiredLength, // 需求总长度
      availableLengths, // 可用长度数组
      segments // 当前尝试的段数
    );
    // 如果找到了合适的组合
    if (combination) {
      // createMultiSegmentSteel：类的方法，用于根据组合结果生成多段组合钢材对象
      // 返回该对象，方法执行到此结束
      return this.createMultiSegmentSteel(combination, pool);
    }
  }

  // 如果所有段数都无法满足需求，返回null
  return null;
}



// core/remainder/RemainderManager.js

class RemainderManager {
  constructor(wasteThreshold = null) {
    // this: 指向当前被创建的 RemainderManager 实例对象。
    // wasteThreshold: 废料阈值。任何长度小于这个值的钢材片段都会被认为是废料。
    // ??: 空值合并运算符。如果 wasteThreshold 是 null 或 undefined，则使用后面的默认值。
    // constraintManager.getWasteThreshold(): 从全局约束配置中心获取默认的废料阈值，消除了硬编码。
    this.wasteThreshold = wasteThreshold ?? constraintManager.getWasteThreshold();

    // this.remainderPools: 一个对象（字典），用于存放【所有可用】的余料。
    // 它的键(key)是规格组合键(groupKey)，值(value)是一个数组，数组里存放的是该规格下所有【待定】或【真】余料对象。
    // 这个池子是“干净”的，绝不允许废料进入。
    this.remainderPools = {}; 

    // this.wasteBin: 【核心新增】一个对象（字典），这就是我们的“废料仓”。
    // 它的结构和 remainderPools 完全一样，但用途相反：专门用于存放【所有被判定为废料】的余料对象。
    // 通过这个设计，我们将“可用”和“废料”在物理存储上彻底分离。
    this.wasteBin = {};

    // this.usageHistory: 记录余料被使用的历史，用于追溯和调试。
    this.usageHistory = {};

    // this.remainderCounters: 余料编号的计数器，确保生成的余料ID是唯一的。
    this.remainderCounters = {};
    
    console.log(`📋 余料管理器初始化完成，废料阈值: ${this.wasteThreshold}mm`);
  }

  initializePool(groupKey) {
    // groupKey: 一个字符串，代表钢材的唯一规格，例如 'Q345B_200'。
    // !this.remainderPools[groupKey]: 检查这个规格的余料池是否已经存在。
    // 如果不存在，说明这是第一次处理这个规格的钢材，需要为它创建所有相关的存储空间。
    if (!this.remainderPools[groupKey]) {
      // 为这个规格创建一个空的【可用余料池】数组。
      this.remainderPools[groupKey] = [];
      // 为这个规格创建一个空的【使用历史】数组。
      this.usageHistory[groupKey] = [];
      // 【核心新增】为这个规格创建一个空的【废料仓】数组。
      // 这一步至关重要，确保了废料仓和余料池是同步创建的，避免了后续操作的错误。
      this.wasteBin[groupKey] = [];
      // 为这个规格创建一个空的【编号计数器】对象。
      this.remainderCounters[groupKey] = { letterIndex: 0, numbers: {} };
    }
  }
  // ...
}